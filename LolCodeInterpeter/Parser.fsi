// Signature file for parser generated by fsyacc
module Parser
type token = 
  | TROOF of (bool)
  | NUMBAR of (double)
  | NUMBR of (int)
  | YARN of (string)
  | IDENTIFIER of (string)
  | NOT
  | IS
  | NOW
  | GIMMEH
  | WTF
  | OMG
  | OMGWTF
  | PRODUKT
  | QUOSHUNT
  | BIGGR
  | SMALLR
  | MOD
  | GTFO
  | SAEM
  | DIFFRINT
  | SMOOSH
  | MKAY
  | MAEK
  | AN
  | DIFF
  | IM
  | IN
  | YR
  | TIL
  | WILE
  | OUTTA
  | UPPIN
  | NERFIN
  | BOTH
  | EITHER
  | MEBBE
  | HELLO
  | END
  | COMMA
  | EOF
  | I
  | HAZ
  | A
  | RRLY
  | RLY
  | OH
  | YA
  | OIC
  | NO
  | WAI
  | ITZ
  | R
  | SUM
  | OF
  | T_NUMBR
  | T_NUMBAR
  | T_TROOF
  | T_YARN
  | T_NOOB
  | PRINT
  | NEWLINE
type tokenId = 
    | TOKEN_TROOF
    | TOKEN_NUMBAR
    | TOKEN_NUMBR
    | TOKEN_YARN
    | TOKEN_IDENTIFIER
    | TOKEN_NOT
    | TOKEN_IS
    | TOKEN_NOW
    | TOKEN_GIMMEH
    | TOKEN_WTF
    | TOKEN_OMG
    | TOKEN_OMGWTF
    | TOKEN_PRODUKT
    | TOKEN_QUOSHUNT
    | TOKEN_BIGGR
    | TOKEN_SMALLR
    | TOKEN_MOD
    | TOKEN_GTFO
    | TOKEN_SAEM
    | TOKEN_DIFFRINT
    | TOKEN_SMOOSH
    | TOKEN_MKAY
    | TOKEN_MAEK
    | TOKEN_AN
    | TOKEN_DIFF
    | TOKEN_IM
    | TOKEN_IN
    | TOKEN_YR
    | TOKEN_TIL
    | TOKEN_WILE
    | TOKEN_OUTTA
    | TOKEN_UPPIN
    | TOKEN_NERFIN
    | TOKEN_BOTH
    | TOKEN_EITHER
    | TOKEN_MEBBE
    | TOKEN_HELLO
    | TOKEN_END
    | TOKEN_COMMA
    | TOKEN_EOF
    | TOKEN_I
    | TOKEN_HAZ
    | TOKEN_A
    | TOKEN_RRLY
    | TOKEN_RLY
    | TOKEN_OH
    | TOKEN_YA
    | TOKEN_OIC
    | TOKEN_NO
    | TOKEN_WAI
    | TOKEN_ITZ
    | TOKEN_R
    | TOKEN_SUM
    | TOKEN_OF
    | TOKEN_T_NUMBR
    | TOKEN_T_NUMBAR
    | TOKEN_T_TROOF
    | TOKEN_T_YARN
    | TOKEN_T_NOOB
    | TOKEN_PRINT
    | TOKEN_NEWLINE
    | TOKEN_end_of_input
    | TOKEN_error
type nonTerminalId = 
    | NONTERM__startstart
    | NONTERM_start
    | NONTERM_Program
    | NONTERM_StatementList
    | NONTERM_Statement
    | NONTERM_Print
    | NONTERM_Input
    | NONTERM_Switch
    | NONTERM_Cases
    | NONTERM_Case
    | NONTERM_DefaultCase
    | NONTERM_Conditional
    | NONTERM_Mebbe
    | NONTERM_Loop
    | NONTERM_LoopOperation
    | NONTERM_LoopTerminator
    | NONTERM_Variable
    | NONTERM_VariableInitializer
    | NONTERM_Unary
    | NONTERM_Expression
    | NONTERM_ExpressionList
    | NONTERM_Literal
    | NONTERM_BooleanOperator
    | NONTERM_ComparisonOperator
    | NONTERM_CalcOperator
    | NONTERM_Type
/// This function maps tokens to integer indexes
val tagOfToken: token -> int

/// This function maps integer indexes to symbolic token ids
val tokenTagToTokenId: int -> tokenId

/// This function maps production indexes returned in syntax errors to strings representing the non terminal that would be produced by that production
val prodIdxToNonTerminal: int -> nonTerminalId

/// This function gets the name of a token as a string
val token_to_string: token -> string
val start : (Microsoft.FSharp.Text.Lexing.LexBuffer<'cty> -> token) -> Microsoft.FSharp.Text.Lexing.LexBuffer<'cty> -> ( AST.Statement list ) 
